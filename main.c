/*! @file main.c
 *
 *  @brief Convert GPS data from GPMF to VBO to use in Circuit Tools
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>

#include "gpmf-parser/GPMF_parser.h"
#include "GPMF_mp4reader.h"
#include "gpmf-parser/GPMF_utils.h"

#define	GPS9_FOUR_CC			STR2FOURCC("GPS9")
#define MS_TO_KMH(v)      3.6*v   

typedef struct {
  double lat;
  double lng;
  double alt;
  double twodspeed;
  double threedspeed;
  double days;
  double secs;
  double dop;
  double fix;
} GPS9;

extern void PrintGPMF(GPMF_stream* ms);

void PrintVBOHeader() {
  printf("[header]\n");
  printf("satellites\n");
  printf("time\n");
  printf("latitude\n");
  printf("longitude\n");
  printf("velocity kmh\n");
  printf("heading\n");
  printf("height\n");
  printf("avifileindex\n");
  printf("avisynctime\n");
  printf("\n");

  printf("[comments]\n");
  printf("Generated by GPMF-TO-VBO\n");
  printf("\n");

  printf("[avi]\n");
  printf("GX010001\n");
  printf("MP4\n");
  printf("\n");

  printf("[column names]\n");
  printf("sats time lat long velocity heading height avifileindex avisynctime\n");
  printf("\n");

  printf("[data]\n");

}

void PrintVBO(GPS9 *data, uint32_t offset_millis) {
  // sats time lat long velocity heading height
  
  // stas
  char *satelites = "008";

  // time
  // Time: This is UTC time since midnight in the form HH:MM:SS.SS.
  char* time;
  // printf("%.8f", data->secs);
  uint32_t millis = (uint32_t) (data->secs * 1000);
  uint32_t hours = millis / (1000 * 60 * 60);
  uint32_t minutes = (millis - hours * 1000 * 60 * 60) / (1000 * 60);
  uint32_t seconds = (millis - hours * 1000 * 60 * 60 - minutes * 1000 * 60) / 1000;
  uint32_t milliseconds = millis % 1000;
  if (0 > asprintf(&time, "%02d%02d%02d.%02d", hours, minutes, seconds, milliseconds))
      return;

  // lat
  char *lat;
  if (0 > asprintf(&lat, "%+5.8f", data->lat * 60.0))
      return;

  // long
  char *lng;
  if (0 > asprintf(&lng, "%+5.8f", data->lng * -60.0))
      return;
  
  // velocity in km/h (needs conversion from m/s)
  char *velocity;
  if (0 > asprintf(&velocity, "%.3f", MS_TO_KMH(data->twodspeed)))
      return;

  // heading
  char *heading = "000.00";

  // height
  char *height;
  if (0 > asprintf(&height, "%+4.2f", data->alt))
    return;

  // avifileindex
  char *avifileindex = "0001";

  // avisynctime
  char *avisynctime; // 000000000
  if (0 > asprintf(&avisynctime, "%09d", offset_millis))
      return;

  printf("%s %s %s %s %s %s %s %s %s\n", satelites, time, lat, lng, velocity, heading, height, avifileindex, avisynctime);

  free(time);
  free(lat);
  free(lng);
  free(velocity);
  free(height);
  free(avisynctime);
}

int main(int argc, char* argv[])
{
	GPMF_ERR ret = GPMF_OK;
	GPMF_stream metadata_stream, * ms = &metadata_stream;
	double metadatalength;
	uint32_t* payload = NULL;
	uint32_t payloadsize = 0;
	size_t payloadres = 0;

	// get file return data
	if (argc != 2)
	{
    printf("Specify exactly one argument.");
		return -1;
	}

	size_t mp4handle = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE, 0);
	if (mp4handle == 0)
	{
		printf("error: %s is an invalid MP4/MOV or it has no GPMF data\n\n", argv[1]);

		return -1;
	}

	metadatalength = GetDuration(mp4handle);

	if (metadatalength > 0.0)
	{
		uint32_t index, payloads = GetNumberPayloads(mp4handle);
    PrintVBOHeader();

		for (index = 0; index < payloads; index++)
		{
			payloadsize = GetPayloadSize(mp4handle, index);
			payloadres = GetPayloadResource(mp4handle, payloadres, payloadsize);
			payload = GetPayload(mp4handle, payloadres, index);
			if (payload == NULL) {
        printf("NULL payload");
				goto cleanup;
      }

			double payload_start_time = 0.0, payload_end_time = 0.0; //times
			ret = GetPayloadTime(mp4handle, index, &payload_start_time, &payload_end_time);
			if (ret != GPMF_OK)
				goto cleanup;

			ret = GPMF_Init(ms, payload, payloadsize);
			if (ret != GPMF_OK) {
        printf("Failed GPMF_Init.");
				goto cleanup;
      }

      while (GPMF_OK == GPMF_FindNext(ms, STR2FOURCC("STRM"), GPMF_RECURSE_LEVELS|GPMF_TOLERANT)) //GoPro Hero5/6/7 Accelerometer)
      {
        if (GPMF_OK != GPMF_FindNext(ms, GPS9_FOUR_CC, GPMF_RECURSE_LEVELS|GPMF_TOLERANT))
          continue;

        char* rawdata = (char*)GPMF_RawData(ms);
        uint32_t samples = GPMF_Repeat(ms); // number of samples

        if (samples)
        {
          GPMF_stream find_stream;
          uint32_t sampledatasize = sizeof(GPS9) * samples;

          GPS9 *sampledata = (GPS9 *)malloc(sampledatasize);
          
          if (sampledata)
          {
            uint32_t i, j;

            //GPMF_FormattedData(ms, tmpbuffer, buffersize, 0, samples); // Output data in LittleEnd, but no scale
            if (GPMF_OK == GPMF_ScaledData(ms, sampledata, sampledatasize, 0, samples, GPMF_TYPE_DOUBLE)) // Output scaled data as floats
            {
              uint32_t sampleidx;
              GPS9 *sampleptr = sampledata;
              
              for (sampleidx = 0; sampleidx < samples; sampleidx++) {
                PrintVBO(sampleptr, (uint32_t) ((payload_start_time + sampleidx * (1.0 / samples)) * 1000));
                sampleptr += 1;
              }
            }
            free(sampledata);
          }
        }
      }
      GPMF_ResetState(ms);
    }

	cleanup:
		if (payloadres) FreePayloadResource(mp4handle, payloadres);
		if (ms) GPMF_Free(ms);
		CloseSource(mp4handle);
	}

	if (ret != 0)
	{
		if (GPMF_ERROR_UNKNOWN_TYPE == ret)
			printf("Unknown GPMF Type within\n");
		else
			printf("GPMF data has corruption\n");
	}

	return (int)ret;
}
